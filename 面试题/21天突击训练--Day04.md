## 21天突击训练--Day04

1. React的组件间通信都有哪些形式？

   - 父组件向子组件通信: props
   - 子组件向父组件通信: 回调函数/自定义事件
   - 跨级组件通信: 层层组件传递props/context
   - 没有嵌套关系组件之间的通信: 自定义事件发布订阅模式

2. React中如何实现路由的懒加载

   - 使用import(),返回一个Promise对象
   - 使用React自带的 Suspense,lazy实现懒加载

3. React中生命周期函数都有哪些？分别有什么作用？

   **React16.3之前**生命周期

   **第一次渲染**

   constructor → componentWillMount → render → componentDidMount

   **props更新**

   componentWillReceiveProps → shouldComponentUpdate(如果返回true) → componentWillUpdate → render → componentDidUpdate

   **state更新**

   shouldComponentUpdate (如果返回true)→ componentWillUpdate → render → componentDidUpdate

   **组件卸载**

   componentWillUnmount

   **React 16.4之后**

   少了componentWillMount, componentWillReceiveProps, componentWillUpdate

   多了两个是getDerivedStateFromProps和getSnapshotBeforeUpdate，其中getDerivedStateFromProps在第一次渲染和更新的时候都会被调用，而getSnapshotBeforeUpdate只会在更新的时候被调用。

   **React 16.8之后** **React Hooks**

4. 说下Vue生命周期钩子函数？

   | 生命周期      | 描述                                                         |
   | :------------ | :----------------------------------------------------------- |
   | beforeCreate  | 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 |
   | Created       | 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，`$el` property 目前尚不可用 |
   | beforeMount   | 在挂载之前开始调用：相关的render函数首次被调用               |
   | Mounted       | **vue2.x:**实例被挂载后调用，这时 `el` 被新创建的 `vm.$el` 替换了。如果根实例挂载到了一个文档内的元素上，当 `mounted` 被调用时 `vm.$el` 也在文档内。 **Vue3.0:**实例被挂载后调用，这时 `Vue.createApp({}).mount()` 被新创建的 `vm.$el` 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 `vm.$el` 也在文档内。 注意 `mounted` 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 `mounted` 内部使用 [vm。$nextTick](https://v3.cn.vuejs.org/api/instance-methods.html#nexttick)： |
   | beforeUpdate  | 组件数据更新之前调用，发生在虚拟DOM打补丁之前                |
   | Update        | 组件数据更新之后                                             |
   | Activated     | keep-alive专属，组件被激活时调用                             |
   | Deadctivated  | keep-alive专属，组件被销毁时调用                             |
   | beforeDestory | 组件销毁之前调用,**在vue3.0生命周期被替代**                  |
   | Destroyed     | 组件销毁之后调用,**在vue3.0生命周期被替代**                  |
   | beforeUnmount | **Vue3.0新增** 在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。 |
   | Unmounted     | **Vue3.0新增** 卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。 |

5. vue中computed和watch区别？

- computed:
  1. computed 是计算属性，也就是计算值，它更多用于计算值的场景；
  2. computed 具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值才会重新调用对应的getter来计算；
  3. computed使用于计算比较消耗性能的计算场景。
- watch:
  1. 更多的是"观察"的作用，类似于某些数据的监听回调，用于观察props，$emit或者本组件的值，当数据变化时来执行回调进行后的操作。
  2. 无缓存性，页面渲染时值不变化也会执行

小结：

1. 当我们进行数值计算，而且依赖于其他的数据，那么把这个数据设计为computed
2. 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化