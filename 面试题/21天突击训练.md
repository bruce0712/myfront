## 21天突击训练

### 第一天

- 编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1。

```js
/**
 * @param {*} array as Array
 * @param {*} k as number
 */
function findNumByIdx(array,k){
    return  Array.from(new Set(array)).sort((a,b)=> b - a )(k-1)
}
```

- `__proto__` 和 prototype 之前有什么关系？

> `__proto__` 是每个对象都有的一个属性；大多数情况下可以理解为 构造器的原型
>
> `__proto__` === constructor.prototype
>
> 但是通过 Object.create()创建的对象有可能不是， Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`
>
> prototype 是函数才有的属性；



-  .call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？

call，apply，bind 这三个函数是 Function原型上的方法 `Function.prototype.call()`，`Function.prototype.apply`，`Function.prototype.bind()`，所有的函数都是 `Funciton` 的实例，因此所有的函数可以调用call，apply，bind 这三个方法。

> **相同点：**
>
> call，apply，bind 这三个方法的第一个参数，都是this。如果你使用的时候不关心 this是谁的话，可以直接设置为 null
>
> **不同点：**
>
> \- 函数调用 call，apply方法时，返回的是调用函数的返回值。
>
> \- 而bind是返回一个新的函数，你需要再加一个小括号来调用。
>
> \- call和apply的区别就是，call接受的是一系列参数，而apply接受的是一个数组。

**bind 方法如何来实现？**

```js
Function.prototype.myBind = function(thisArg) {
    // 保存当前函数的this
    const fn = this;
    // 保存原先的参数
    const args = [...arguments].slice(1);
    // 返回一个新的函数
    return function() {
        // 再次获取新的参数
        const newArgs = [...arguments];
        /**
         * 1.修改当前函数的this为thisArg
         * 2.将多次传入的参数一次性传入函数中
        */
        return fn.apply(thisArg, args.concat(newArgs))
    }
}
```

