## 21天突击训练

### 第一天

- 编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1。

```js
/**
 * @param {*} array as Array
 * @param {*} k as number
 */
function findNumByIdx(array,k){
    return  Array.from(new Set(array)).sort((a,b)=> b - a )(k-1)
}
```

- `__proto__` 和 prototype 之前有什么关系？

> 所有对象都有 `__proto__`属性，函数这个特殊对象除了具有`__proto__`属性，还有特有的原型属性prototype。prototype对象默认有两个属性，constructor属性和`__proto__`属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而`__proto__`是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数。



-  .call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？

call，apply，bind 这三个函数是 Function原型上的方法 `Function.prototype.call()`，`Function.prototype.apply`，`Function.prototype.bind()`，所有的函数都是 `Funciton` 的实例，因此所有的函数可以调用call，apply，bind 这三个方法。

> **相同点：**
>
> call，apply，bind 这三个方法的第一个参数，都是this。如果你使用的时候不关心 this是谁的话，可以直接设置为 null
>
> **不同点：**
>
> \- 函数调用 call，apply方法时，返回的是调用函数的返回值。
>
> \- 而bind是返回一个新的函数，你需要再加一个小括号来调用。
>
> \- call和apply的区别就是，call接受的是一系列参数，而apply接受的是一个数组。

**bind 方法如何来实现？**

```js
Function.prototype.myBind = function(thisArg) {
    // 保存当前函数的this
    const fn = this;
    // 保存原先的参数
    const args = [...arguments].slice(1);
    // 返回一个新的函数
    return function Fn() {
        // 再次获取新的参数
        const newArgs = [...arguments];
        /**
         * 1.修改当前函数的this为thisArg
         * 2.将多次传入的参数一次性传入函数中
        */
        return fn.apply(this instanceof Fn ? new fn(...argument): thisArgs, args.concat(newArgs))
    }
}
```

